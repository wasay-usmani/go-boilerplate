name: Template Initialization

on:
  # Trigger when repository is created from template
  repository_dispatch:
    types: [template_used]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      module_path:
        description: 'Module path (e.g., github.com/mycompany/my-app)'
        required: true
        default: 'github.com/mycompany/my-app'
        type: string

jobs:
  initialize-template:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
        
    - name: Get module path from repository
      id: module_path
      run: |
        # Extract module path from repository name and owner
        REPO_OWNER="${{ github.repository_owner }}"
        REPO_NAME="${{ github.event.repository.name }}"
        MODULE_PATH="github.com/$REPO_OWNER/$REPO_NAME"
        
        # If manual trigger with custom module path, use that instead
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          MODULE_PATH="${{ github.event.inputs.module_path }}"
        fi
        
        echo "module_path=$MODULE_PATH" >> $GITHUB_OUTPUT
        echo "Using module path: $MODULE_PATH"
        
    - name: Initialize boilerplate
      run: |
        echo "Running make init with module path: ${{ steps.module_path.outputs.module_path }}"
        make init MODULE_PATH="${{ steps.module_path.outputs.module_path }}"
        
    - name: Verify initialization
      run: |
        echo "Verifying initialization..."
        
        # Check if go.mod was updated
        if grep -q "module ${{ steps.module_path.outputs.module_path }}" go.mod; then
          echo "‚úÖ go.mod updated successfully"
        else
          echo "‚ùå go.mod not updated correctly"
          exit 1
        fi
        
        # Check if directories were renamed (if project name is different from go-boilerplate)
        PROJECT_NAME=$(echo "${{ steps.module_path.outputs.module_path }}" | sed 's/.*\///')
        if [ "$PROJECT_NAME" != "go-boilerplate" ]; then
          if [ -d "cmd/$PROJECT_NAME" ]; then
            echo "‚úÖ cmd directory renamed to cmd/$PROJECT_NAME"
          else
            echo "‚ùå cmd directory not renamed correctly"
            exit 1
          fi
          
          if [ -d "internal/$PROJECT_NAME" ]; then
            echo "‚úÖ internal directory renamed to internal/$PROJECT_NAME"
          else
            echo "‚ùå internal directory not renamed correctly"
            exit 1
          fi
          
          if [ -d "resources/$PROJECT_NAME" ]; then
            echo "‚úÖ resources directory renamed to resources/$PROJECT_NAME"
          else
            echo "‚ùå resources directory not renamed correctly"
            exit 1
          fi
        else
          echo "‚ÑπÔ∏è Project name is go-boilerplate, directories not renamed (as expected)"
        fi
        
    - name: Test build
      run: |
        echo "Testing build..."
        make build
        
    - name: Run tests
      run: |
        echo "Running tests..."
        make test
        
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add -A
        git commit -m "Initialize boilerplate with module path: ${{ steps.module_path.outputs.module_path }}"
        
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}
        
    - name: Create success issue
      if: github.event_name == 'repository_dispatch'
      uses: actions/github-script@v7
      with:
        script: |
          const { data: issues } = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'üéâ Template Initialization Complete!',
            body: `## ‚úÖ Boilerplate Successfully Initialized!
          
          Your Go boilerplate has been automatically initialized with the following configuration:
          
          - **Module Path**: \`${{ steps.module_path.outputs.module_path }}\`
          - **Project Name**: \`$(echo "${{ steps.module_path.outputs.module_path }}" | sed 's/.*\///')\`
          
          ## üöÄ Next Steps:
          
          1. **Review the changes** - All import paths and configuration files have been updated
          2. **Update your README.md** - Customize it for your project
          3. **Configure your database** - Update the database configuration in \`resources/\`
          4. **Deploy your application** - Use the provided Dockerfile
          
          ## üìÅ Project Structure:
          
          \`\`\`
          cmd/$(echo "${{ steps.module_path.outputs.module_path }}" | sed 's/.*\///')/
          internal/$(echo "${{ steps.module_path.outputs.module_path }}" | sed 's/.*\///')/
          resources/$(echo "${{ steps.module_path.outputs.module_path }}" | sed 's/.*\///')/
          \`\`\`
          
          ## üõ†Ô∏è Available Commands:
          
          - \`make build\` - Build the application
          - \`make test\` - Run tests
          - \`make clean\` - Clean build artifacts
          - \`make deps\` - Install dependencies
          
          Happy coding! üéØ`
          }); 